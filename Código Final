#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>  
#include <windows.h> 
#include <conio.h>
#include <time.h>

#ifdef _WIN32
    #define CLEAR "cls"  // Comando completo para limpar tela no Windows, else est? para linux e macOs, junto ao 
    #define SLEEP(ms) Sleep(ms)
#else
    #define CLEAR "clear"
    #define SLEEP(ms) usleep(ms * 1000)
#endif

#define RESET "\033[0m"
#define HIGHLIGHT "\033[1;32m" 
#define NORMAL "\033[0;37m"

#define LINHAS 7
#define COLUNAS 4
#define LETRAS "ABCDEFG"
#define MAX_DESTINOS 4
#define MAX_CLIENTE 3
#define MAX_PASSAGENS 3


int prox_id= 1, i, j;

typedef struct {
	char nome[50], trajet[20], tipo[100];
 	int num, cabin;
 	float preco;

} Barco;

typedef struct {
    char rota[50];
    char horario[10];
    char preco[50];
}barco;

struct endereco{

	char cep[9];
	char rua[50];
	char numero[10];
	char bairro[50];
	char cidade[50];
	char estado[50];	
}; 

struct cliente {
    int id;
    char nome[50];
    char cpf[15];
    char data_nasc[11];
    char telefone[20];
    struct cliente *proximo_cl; // Lista encadeada
};

typedef struct {
    char nome[50];
    char usuario[20];
    char senha[20];
    char cargo[20];  // Ex.: "Gerente - geral, interino, " ou "Funcion?rio"
    int cod;
	char cpf[15];
} Funcionario;

// Estrutura de rota (com origem e data)
typedef struct {
    char origem[30];
    char destino[30];
    char data[12];
    char horario[10];
    char preco[10];
    int linhas;
    int colunas;
    int capacidade;
} Rota;

barco Barcos[MAX_DESTINOS] = {
    {"Manaus -> Tabatinga", "08:00", "R$200"},  // Declaração dos barcos
    {"Manaus -> Belém", "10:30", "R$150"}, 
    {"Manaus -> Santarém", "10:00", "R$250"},
    {"Manaus -> Parintins", "11:00", "R$130"}};
    
Rota rotas[MAX_DESTINOS] = {
    {"Manaus", "Tabatinga", "25/11/2024", "08:00", "R$200", 5, 4, 20},
    {"Manaus", "Belém", "26/11/2024", "10:30", "R$150", 7, 4, 28},
    {"Manaus", "Santarém", "27/11/2024", "10:00", "R$250", 6, 4, 24},
    {"Manaus", "Parintins", "28/11/2024", "11:00", "R$130", 8, 4, 32}
	
};

int mostrarMenu(const char *titulo, const char **opcoes, int numOpcoes);
void menuRotas();

// Função para alterar a cor no console
void setColor(int color) {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
}

void toLowerCase(char *str) {
    for (i = 0; str[i]; i++) {
        str[i] = tolower(str[i]);
    }
}

void remover_formatacao_cpf(const char *cpf_formatado, char *cpf_limpo) {
    int i, j = 0;
    for (i = 0; cpf_formatado[i] != '\0'; i++) {
        if (isdigit(cpf_formatado[i])) {
            cpf_limpo[j++] = cpf_formatado[i];
        }
    }
    cpf_limpo[j] = '\0';
}

// Função para validar e formatar CPF
void ler_cpf_formatado(char *cpf) {
    int pos = 0;
    char c;

    printf("CPF: ");
    while (pos < 14) {
        c = getch();

        if (c == '\b' && pos > 0) {
            pos--;
            if (cpf[pos] == '.' || cpf[pos] == '-') pos--;
            cpf[pos] = '\0';
            printf("\b \b");
        } else if (isdigit(c)) {
            if (pos == 3 || pos == 7) {
                cpf[pos++] = '.';
                printf(".");
            } else if (pos == 11) {
                cpf[pos++] = '-';
                printf("-");
            }
            cpf[pos++] = c;
            printf("%c", c);
        }
    }
    cpf[pos] = '\0';
    printf("\n");
}

// Função para calcular idade com base na data de nascimento
int calcular_idade(const char *data_nasc) {
    int dia, mes, ano;
    sscanf(data_nasc, "%d/%d/%d", &dia, &mes, &ano);

    time_t t = time(NULL);
    struct tm tm = *localtime(&t);

    int idade = tm.tm_year + 1900 - ano;

    if (tm.tm_mon + 1 < mes || (tm.tm_mon + 1 == mes && tm.tm_mday < dia)) {
        idade--;
    }

    return idade;
}

// Função para validar e formatar data
int validar_data(const char *data) {
    int dia, mes, ano;

    if (sscanf(data, "%d/%d/%d", &dia, &mes, &ano) != 3) return 0;

    if (ano < 1900 || ano > 2100 || mes < 1 || mes > 12 || dia < 1 || dia > 31) return 0;

    if ((mes == 4 || mes == 6 || mes == 9 || mes == 11) && dia > 30) return 0;
    if (mes == 2) {
        int bissexto = (ano % 4 == 0 && (ano % 100 != 0 || ano % 400 == 0));
        if (dia > (bissexto ? 29 : 28)) return 0;
    }
    return 1;
}

void ler_data_formatada(char *data) {
    int pos = 0;
    char c;

    printf("Data de Nascimento (dd/mm/aaaa): ");
    while (pos < 10) {
        c = getch();
        if (c == '\b' && pos > 0) {
            pos--;
            if (data[pos] == '/') pos--;
            data[pos] = '\0';
            printf("\b \b");
        } else if (isdigit(c)) {
            if (pos == 2 || pos == 5) {
                data[pos++] = '/';
                printf("/");
            }
            data[pos++] = c;
            printf("%c", c);
        }
    }
    data[pos] = '\0';
    printf("\n");
}

// Função para validar e formatar telefone
void ler_telefone_formatado(char *telefone) {
    int pos = 0;
    char c;

    printf("Telefone: ");
    while (pos < 15) {
        c = getch();
        if (c == '\b' && pos > 0) {
            pos--;
            if (telefone[pos] == ')' || telefone[pos] == ' ' || telefone[pos] == '-') pos--;
            telefone[pos] = '\0';
            printf("\b \b");
        } else if (isdigit(c)) {
            if (pos == 0) {
                telefone[pos++] = '(';
                printf("(");
            } else if (pos == 3) {
                telefone[pos++] = ')';
                telefone[pos++] = ' ';
                printf(") ");
            } else if (pos == 9) {
                telefone[pos++] = '-';
                printf("-");
            }
            telefone[pos++] = c;
            printf("%c", c);
        }
    }
    telefone[pos] = '\0';
    printf("\n");
}

// Cadastro de cliente
void cadastrar_cliente(struct cliente **head) {
    struct cliente *novo_cl = (struct cliente *)malloc(sizeof(struct cliente));
    if (!novo_cl) {
        printf("Erro ao alocar memória!\n");
        return;
    }
    novo_cl->id = prox_id++;

    printf("Nome: ");
    fflush(stdin);
    fgets(novo_cl->nome, 50, stdin);
    strtok(novo_cl->nome, "\n");

    do {
        ler_cpf_formatado(novo_cl->cpf);
    } while (strlen(novo_cl->cpf) != 14);

    do {
        ler_data_formatada(novo_cl->data_nasc);
        if (!validar_data(novo_cl->data_nasc)) {
            printf("Data inválida! Tente novamente.\n");
        }
    } while (!validar_data(novo_cl->data_nasc));

    do {
        ler_telefone_formatado(novo_cl->telefone);
    } while (strlen(novo_cl->telefone) != 15);

    novo_cl->proximo_cl = *head;
    *head = novo_cl;

    printf("\nCliente cadastrado com sucesso!\n");
    getch();
}

// Buscar cliente por CPF
struct cliente* buscar_cliente_por_cpf(struct cliente *head, const char *cpf) {
    struct cliente *atual = head;
    char cpf_limpo[12], cpf_atual_limpo[12];

    remover_formatacao_cpf(cpf, cpf_limpo);

    while (atual != NULL) {
        remover_formatacao_cpf(atual->cpf, cpf_atual_limpo);

        if (strcmp(cpf_atual_limpo, cpf_limpo) == 0) {
            // Não precisa imprimir os dados do cliente aqui
            return atual; // Retorna o ponteiro para o cliente encontrado
        }
        atual = atual->proximo_cl;
    }

    return NULL; // Retorna NULL se o cliente não for encontrado
}

// Funções para gerenciar assentos
void inicializarAssentos(char ***assentos, int linhas, int colunas) {
    for (i = 0; i < linhas; i++) {
        for (j = 0; j < colunas; j++) {
            sprintf(assentos[i][j], "%c-%d", LETRAS[i], j + 1);
        }
    }
}

char ***criarAssentos(int linhas, int colunas) {
    char ***assentos = (char ***)malloc(linhas * sizeof(char **));
    for (i = 0; i < linhas; i++) {
        assentos[i] = (char **)malloc(colunas * sizeof(char *));
        for (j = 0; j < colunas; j++) {
            assentos[i][j] = (char *)malloc(4 * sizeof(char));
        }
    }
    inicializarAssentos(assentos, linhas, colunas);
    return assentos;
}

void liberarAssentos(char ***assentos, int linhas, int colunas) {
    for (i = 0; i < linhas; i++) {
        for (j = 0; j < colunas; j++) {
            free(assentos[i][j]);
        }
        free(assentos[i]);
    }
    free(assentos);
}

// Função para exibir os assentos
void mostrarAssentos(char ***assentos, int linhas, int colunas, int posLinha, int posColuna) {
    printf("\n======== MAPA DE ASSENTOS ========\n");
    printf("        [1]  [2]     |   [3]  [4]  \n");
    printf("        /-----------------------\\\n");

    for (i = 0; i < linhas; i++) {
        printf(" [%c] ", LETRAS[i]);
        for (j = 0; j < colunas; j++) {
            if (j == 2) {
                printf("  |  ");
            }

            if (strcmp(assentos[i][j], "X") == 0) {
                setColor(12); // Vermelho para ocupados
                printf(" X   ");
            } else if (i == posLinha && j == posColuna) {
                setColor(14); // Amarelo para o assento selecionado
                printf(" %-4s", assentos[i][j]);
            } else {
                setColor(10); // Verde para disponíveis
                printf(" %-4s", assentos[i][j]);
            }
            setColor(7); // Reset para texto padrão
        }
        printf("\n");
    }
    printf("        \\-----------------------/\n");
    printf("==================================\n");
}

// Seleção de assentos com navegação
int escolherAssento(char ***assentos, int linhas, int colunas, char assentosEscolhidos[MAX_PASSAGENS][5], int *totalAssentosEscolhidos, Rota rota) {
    int posLinha = 0, posColuna = 0;

    while (*totalAssentosEscolhidos < MAX_PASSAGENS) {
        system(CLEAR);

        // Exibindo as informações do barco
        printf("Informações do Barco:\n");
        printf("Rota: %s -> %s\n", rota.origem, rota.destino);
        printf("Data: %s\n", rota.data);
        printf("Horário: %s\n", rota.horario);
        printf("Preço: %s\n", rota.preco);
        printf("Capacidade: %d assentos\n", rota.capacidade);
        printf("\n");

        mostrarAssentos(assentos, linhas, colunas, posLinha, posColuna);

        printf("\nUse as setas para navegar e pressione Enter para confirmar o assento.\n");
        printf("Pressione 'f' para finalizar a seleção, 'v' para voltar ao menu ou 'q' para sair.\n");

        int tecla = _getch();

        if (tecla == 224) { // Teclas de seta
            tecla = _getch();
            switch (tecla) {
                case 72: // Seta para cima
                    if (posLinha > 0) posLinha--;
                    break;
                case 80: // Seta para baixo
                    if (posLinha < linhas - 1) posLinha++;
                    break;
                case 75: // Seta para esquerda
                    if (posColuna > 0) posColuna--;
                    break;
                case 77: // Seta para direita
                    if (posColuna < colunas - 1) posColuna++;
                    break;
            }
        } else if (tecla == 13) { // Enter
            if (strcmp(assentos[posLinha][posColuna], "X") == 0) {
                printf("Assento já ocupado! Tente novamente.\n");
                _getch();
            } else {
                strcpy(assentos[posLinha][posColuna], "X");
                snprintf(assentosEscolhidos[*totalAssentosEscolhidos], 5, "%c-%d", LETRAS[posLinha], posColuna + 1);
                (*totalAssentosEscolhidos)++;
                printf("Assento %c-%d selecionado com sucesso!\n", LETRAS[posLinha], posColuna + 1);
                _getch();
            }
        } else if (tecla == 'f' || tecla == 'F') { // Finalizar seleção
            break;
        } else if (tecla == 'v' || tecla == 'V') { // Voltar
            return -1;
        } else if (tecla == 'q' || tecla == 'Q') { // Sair
            return 0;
        }
    }
    return 1;
}

// Função para comparar preços de rotas (para ordenação)
int compararPorPreco(const void *a, const void *b) {
    Rota *rotaA = (Rota *)a;
    Rota *rotaB = (Rota *)b;
    return strcmp(rotaA->preco, rotaB->preco);
}

// Função para comparar capacidade de rotas (para ordenação)
int compararPorCapacidade(const void *a, const void *b) {
    Rota *rotaA = (Rota *)a;
    Rota *rotaB = (Rota *)b;
    return rotaB->capacidade - rotaA->capacidade;
}

int finalizarCompra(int totalAssentos, Rota rota, char assentosEscolhidos[MAX_PASSAGENS][5]) {
    char opcao;
    float preco_total;

    system(CLEAR);
    printf("===== FINALIZAR COMPRA =====\n\n");
    printf("Inteira ou Meia? (I/M): ");
    scanf(" %c", &opcao);

    if (opcao == 'I' || opcao == 'i') {
        preco_total = totalAssentos * atof(rota.preco + 2); // Converte o preço da rota para float, ignorando "R$"
    } else if (opcao == 'M' || opcao == 'm') {
        printf("Necessário comprovação de benefício\n");
        Sleep(2000);
        preco_total = totalAssentos * (atof(rota.preco + 2) / 2); // Converte o preço da rota para float, ignorando "R$"
    } else {
        printf("Opção inválida! Pressione qualquer tecla para continuar.\n");
        _getch();
        finalizarCompra(totalAssentos, rota, assentosEscolhidos); // Reinicia a função
        return 1;
    }

    system(CLEAR);
    printf("===== FINALIZAR COMPRA =====\n");
    printf("Rota: %s -> %s\n", rota.origem, rota.destino);
    printf("Data: %s\n", rota.data);
    printf("Horário: %s\n", rota.horario);
    printf("Assentos Selecionados:\n");
    for (i = 0; i < totalAssentos; i++) {
        printf("- %s\n", assentosEscolhidos[i]);
    }
    printf("Preço total: R$ %.2f\n", preco_total);
    printf("============================\n");
    printf("Confirma compra? (S/N): ");
    scanf(" %c", &opcao);

    if (opcao == 'S' || opcao == 's') {
        // TODO: Imprimir comprovante ou finalizar a compra
        printf("Compra confirmada! Pressione qualquer tecla para continuar.\n");
        _getch();
        return 0;
    } else {
        printf("Compra cancelada! Voltando ao Menu Principal...\n");
        _getch();
        return 0;
    }
}

// Função para exibir os detalhes da compra e permitir a troca de assentos
int detalhesDaCompra(char assentosEscolhidos[MAX_PASSAGENS][5], int totalAssentos, Rota rota, char ***assentos, struct cliente **head_cliente) {
    char resposta; // Variável para armazenar a resposta do usuário
    char cpf_busca[15]; // Variável para armazenar o CPF do cliente
    struct cliente cliente_temp; // Variável temporária para armazenar os dados do cliente

    system(CLEAR);
    printf("======= DETALHES DA COMPRA =======\n");
    printf("Rota: %s -> %s\n", rota.origem, rota.destino);
    printf("Data: %s\n", rota.data);
    printf("Horário: %s\n", rota.horario);
    printf("Assentos Selecionados:\n");
    for (i = 0; i < totalAssentos; i++) {
        printf("- %s\n", assentosEscolhidos[i]);
    }
    printf("===============================\n");

    // Pergunta sobre o cadastro do cliente
    printf("Cliente possui cadastro? (S/N): ");
    scanf(" %c", &resposta);

    if (resposta == 'S' || resposta == 's') {
        system(CLEAR);
        printf("=== BUSCAR CLIENTE POR CPF ===\n");
        printf("Digite o CPF do cliente");
        printf("\n");
        ler_cpf_formatado(cpf_busca);

        // Chama a função buscar_cliente_por_cpf e armazena o resultado
        struct cliente *cliente_encontrado = buscar_cliente_por_cpf(*head_cliente, cpf_busca); 

        if (cliente_encontrado != NULL) { // Verifica se o cliente foi encontrado
            printf("\nCliente Identificado: %s!!! Prosseguir com a compra? (S/N) ", cliente_encontrado->nome); 
            scanf(" %c", &resposta);
            if (resposta == 'S' || resposta == 's') {
                finalizarCompra(totalAssentos, rota, assentosEscolhidos); // Chama a função finalizarCompra
            } else {
                printf("Compra cancelada! Voltando ao Menu Principal...\n");
                _getch();
                return 0; // Retorna ao menu principal
            }
        } else {
            // Cliente não encontrado - talvez voltar ao menu ou perguntar se quer cadastrar
            printf("Cliente não encontrado. Pressione qualquer tecla para continuar...\n");
            _getch();
        }
    } else if (resposta == 'N' || resposta == 'n') {
        printf("Cliente deseja realizar cadastro? (S/N): ");
        scanf(" %c", &resposta);
        if (resposta == 'S' || resposta == 's') {
            system(CLEAR);
            printf("=== CADASTRAR CLIENTE ===\n");
            cadastrar_cliente(head_cliente);

            // Após cadastrar, exibir a mensagem personalizada
            printf("\nCliente Identificado: %s!!! Prosseguir com a compra? (S/N) ", (*head_cliente)->nome); // Acessa o nome do cliente recém-cadastrado
            scanf(" %c", &resposta);
            if (resposta == 'S' || resposta == 's') {
                finalizarCompra(totalAssentos, rota, assentosEscolhidos); // Chama a função finalizarCompra
            } else {
                printf("Compra cancelada! Voltando ao Menu Principal...\n");
                _getch();
                return 0; // Retorna ao menu principal
            }
        } else {
            // Lógica para coletar dados do cliente sem cadastro
            printf("=== INFORMAÇÕES DO CLIENTE ===\n");

            printf("Nome: ");
            fflush(stdin);
            fgets(cliente_temp.nome, 50, stdin);
            strtok(cliente_temp.nome, "\n");

            ler_cpf_formatado(cliente_temp.cpf);
            ler_telefone_formatado(cliente_temp.telefone);

            printf("\nCliente %s pronto para embarque!!! Prosseguir com a compra? (S/N) ", cliente_temp.nome);
            scanf(" %c", &resposta);
            if (resposta == 'S' || resposta == 's') {
                finalizarCompra(totalAssentos, rota, assentosEscolhidos); // Chama a função finalizarCompra
            } else {
                printf("Compra cancelada! Voltando ao Menu Principal...\n");
                _getch();
                return 0; // Retorna ao menu principal
            }
        }
    } else {
        printf("Resposta inválida! Pressione qualquer tecla para continuar.\n");
        _getch();
    }

    return 0; // Finaliza a função
}

// Função para listar as rotas disponíveis (usando a função genérica mostrarMenu)
void listarRotas(struct cliente **head_cliente) {
    const char *opcoes[MAX_DESTINOS];
    for (i = 0; i < MAX_DESTINOS; i++) {
        char temp[50];
        sprintf(temp, "%d. %s -> %s - %s - %s", i + 1, rotas[i].origem, rotas[i].destino, rotas[i].data, rotas[i].horario);
        opcoes[i] = strdup(temp); // Aloca memória para a string
    }

    int escolha = mostrarMenu("MENU DE ROTAS", opcoes, MAX_DESTINOS);

    if (escolha >= 0 && escolha < MAX_DESTINOS) {
        Rota rotaSelecionada = rotas[escolha];
        char ***assentos = criarAssentos(rotaSelecionada.linhas, rotaSelecionada.colunas);
        char assentosEscolhidos[MAX_PASSAGENS][5];
        int totalAssentosEscolhidos = 0;

        int resultado = escolherAssento(assentos, rotaSelecionada.linhas, rotaSelecionada.colunas, assentosEscolhidos, &totalAssentosEscolhidos, rotaSelecionada);
        if (resultado == 1 && totalAssentosEscolhidos > 0) {
            detalhesDaCompra(assentosEscolhidos, totalAssentosEscolhidos, rotaSelecionada, assentos, head_cliente); // Passa head_cliente para detalhesDaCompra
        }
        liberarAssentos(assentos, rotaSelecionada.linhas, rotaSelecionada.colunas);
    }

    // Libera a memória alocada para as strings
    for (i = 0; i < MAX_DESTINOS; i++) {
        free((char *)opcoes[i]);
    }
}

// Função para filtrar rotas (usando a função genérica mostrarMenu)
void filtrarRotas(int filtro, struct cliente **head_cliente) {
    // Ordena as rotas com base no filtro
    if (filtro == 1) {
        qsort(rotas, MAX_DESTINOS, sizeof(Rota), compararPorCapacidade);
    } else if (filtro == 2) {
        qsort(rotas, MAX_DESTINOS, sizeof(Rota), compararPorPreco);
    }

    const char *opcoes[MAX_DESTINOS + 1]; // +1 para a opção "Voltar"
    for (i = 0; i < MAX_DESTINOS; i++) {
        char temp[80];
        sprintf(temp, "%d. %s -> %s - %s - %s - %s", i + 1, rotas[i].origem, rotas[i].destino, rotas[i].data, rotas[i].horario, rotas[i].preco);
        opcoes[i] = strdup(temp);
    }
    opcoes[MAX_DESTINOS] = "Voltar ao menu principal";

    int escolha = mostrarMenu(filtro == 1 ? "DESTINOS MAIS POPULARES" : "DESTINOS MAIS ACESSÍVEIS", opcoes, MAX_DESTINOS + 1);

    if (escolha >= 0 && escolha < MAX_DESTINOS) {
        Rota rotaSelecionada = rotas[escolha];
        char ***assentos = criarAssentos(rotaSelecionada.linhas, rotaSelecionada.colunas);
        char assentosEscolhidos[MAX_PASSAGENS][5];
        int totalAssentosEscolhidos = 0;

        int resultado = escolherAssento(assentos, rotaSelecionada.linhas, rotaSelecionada.colunas, assentosEscolhidos, &totalAssentosEscolhidos, rotaSelecionada);
        if (resultado == 1 && totalAssentosEscolhidos > 0) {
            detalhesDaCompra(assentosEscolhidos, totalAssentosEscolhidos, rotaSelecionada, assentos, head_cliente); // Passa head_cliente para detalhesDaCompra
        }
        liberarAssentos(assentos, rotaSelecionada.linhas, rotaSelecionada.colunas);
    }

    // Libera a memória alocada para as strings
    for (i = 0; i <= MAX_DESTINOS; i++) { // <= para incluir a opção "Voltar"
        free((char *)opcoes[i]);
    }
}

// Animação de barco navegando no terminal
void animarBarco() {
    const char *frames[] = {
    	"\n\n"
        "       ~~~~~~            \n"
        "     ~~~~~~~~~~          \n"
        "    ~~~~~~~~~~~~         \n"
        "   __|____|_____\\____    \n"
        "  |                |      \n"
        "  |  BANZEIRO  |~~~   \n"
        "~~~~~~~~~~~~~~~~~~~~~~~~~ \n",
        "\n\n"
        "     ~~~~~~~~~~           \n"
        "   ~~~~~~~~~~~~~~~        \n"
        "  ~~~~~~~~~~~~~~~~~~~     \n"
        " __|____|______/_____\\_   \n"
        "|                |        \n"
        "|  BANZEIRO  | ~~~~   \n"
        "~~~~~~~~~~~~~~~~~~~~~~~~~ \n",
        "\n\n"
        "   ~~~~~~~~~~~~~~~~       \n"
        " ~~~~~~~~~~~~~~~~~~~~     \n"
        "~~~~~~~~~~~~~~~~~~~~~~~   \n"
        "____|___|_______/_____\\_  \n"
        "|                |        \n"
        "|  BANZEIRO  | ~~~~~  \n"
        "~~~~~~~~~~~~~~~~~~~~~~~~~ \n"
    };
    

    // Loop para exibir os frames em sequência, criando a animação
    int i;
	for ( i = 0; i < 10; i++) {
        system(CLEAR);
        printf("%s", frames[i % 3]);
        fflush(stdout);  // Garante que o frame seja exibido
        SLEEP(300);  // Espera 300ms entre os frames
    }
}

void animacaoBarco() {
	const char *frames[] = {
    "\n\n"
	"   ~     ~ \n"
    "      ~    ~   \n"
    "    ~    ~    ~   ~   ~ \n"
    "        ~      \n",
    "   ~  \n"
    "      ~    ~ \n"
    "    ~    ~\n"
    "       \n",
    "   ~     ~    ~\n"
    "      ~    ~      ~    ~\n"
    "    ~    ~    ~   ~   ~   ~\n"
    "        ~      ~     ~\n",
	
	};

	 int i;
	for ( i = 0; i < 10; i++) {
        system(CLEAR);
        printf("%s", frames[i % 3]);
        fflush(stdout);  // Garante que o frame seja exibido
        SLEEP(300);  // Espera 300ms entre os frames
	}
		printf("\nBarco pronto para embarque!\n");
		SLEEP(1500);
}

void salvarFuncionario(const char *arquivo, Funcionario *usuario) {
    FILE *fp = fopen(arquivo, "wb");
    if (fp) {
        fwrite(usuario, sizeof(Funcionario), 1, fp);
        fclose(fp);
    }
}

int carregarFuncionario(const char *arquivo, Funcionario *usuario) {
    FILE *fp = fopen(arquivo, "rb");
    if (fp) {
        fread(usuario, sizeof(Funcionario), 1, fp);
        fclose(fp);
        return 1;  // Sucesso
    }
    return 0;  // Falha
}

Funcionario* cadas_funcis(Funcionario *funcis, int *n){
	system("cls");
	setlocale(LC_ALL, "Portuguese");
	(*n)++;
    funcis = (Funcionario*)realloc(funcis, (*n) * sizeof(Funcionario));
    if (funcis == NULL) {
        printf("Erro ao alocar memória\n");
        exit(1);
    }

    Funcionario novo_funcis;
    novo_funcis.cod = *n;
    
	printf("\n ========== Cadastrar Funcionário ==========\n\n");
	printf(" ________________________________________\n");
	printf("|                                        \n");
	printf("|  Digite nome do funcionário: ");
	getchar();
	fflush(stdin);
	fgets(novo_funcis.nome, 50, stdin);
	novo_funcis.nome[strcspn(novo_funcis.nome, "\n")] = 0;
	printf("|  ");
	do {
        ler_cpf_formatado(novo_funcis.cpf);
    } while (strlen(novo_funcis.cpf) != 14);
    fflush(stdin);
	printf("|  Digite função do funcionário: ");
	getchar();
	fgets(novo_funcis.cargo, 20, stdin);
	novo_funcis.cargo[strcspn(novo_funcis.cargo, "\n")] = 0;
	printf("|                                        \n");
	printf("|________________________________________\n");
	funcis[(*n) - 1] = novo_funcis;
	printf("\n\t\tCadastrado\n");
	printf("\nPressione qualquer tecla para continuar");
	system("pause > nul");
	system("CLS");
 						
	return funcis;
}

void atual_funcis(Funcionario *funcis, int n) {
	system("cls");
	setlocale(LC_ALL, "Portuguese");
	int cod, i;
	char cpf[15];
	
	printf("\n ========== Atualizar Funcionário ==========\n\n");
	
    if (n == 0) {
        printf("\n\tNenhum cliente cadastrado.\n");
        printf("\nPressione qualquer tecla para continuar");
		system("pause > nul");
		system("CLS");
        return;
    }
    
    printf("\nDigite o codigo do funcionário que deseja atualizar: \n");
    scanf("%d", &cod);
    printf("\n\nDigite o CPF do funcionário que deseja atualizar: \n");
    scanf("%d", &cpf);

    for (i = 0; i < n; i++) {
        if (funcis[i].cod == cod || funcis[i].cpf == cpf) {
            printf("\nAtualizando dados do funcionario com codigo %d...\n", cod);
            printf(" ________________________________________\n");
			printf("|                                        \n");
			printf("|  Atualize o nome do funcionário: ");
			getchar();
			fflush(stdin);
			fgets(funcis[i].nome, 50, stdin);
			funcis[i].nome[strcspn(funcis[i].nome, "\n")] = 0;
			printf("|  Atualize o CPF do funcionário: ");
			do {
        		ler_cpf_formatado(funcis[i].cpf);
    		} while (strlen(funcis[i].cpf) != 14);
			printf("|  Atualize a função do funcionário: ");
			getchar();
			fflush(stdin);
			fgets(funcis[i].cargo, 20, stdin);
			funcis[i].cargo[strcspn(funcis[i].cargo, "\n")] = 0;
			printf("|                                        \n");
			printf("|      Dados atualizados com sucesso!\n");
			printf("|________________________________________\n");
			printf("\n\t\tAtualizado!\n");
			printf("\nPressione qualquer tecla para continuar");
 			system("pause > nul");
 			system("CLS");
	
            return;
        }
    }
    printf("Funcionário com codigo %d não encontrado.\n", cod);
    printf("\nPressione qualquer tecla para continuar");
 	system("pause > nul");
 	system("CLS");
}

Funcionario* demit_funcis(Funcionario *funcis, int *n) {
	system("cls");
	setlocale(LC_ALL, "Portuguese");
	int cod, i, j;
	char cpf[15];
	
	printf("\n =========== Demitir Funcionarios ===========\n\n");
	
    if (*n == 0) {
        printf("\n\tNenhum funcionário cadastrado.\n");
        printf("\nPressione qualquer tecla para continuar");
		system("pause > nul");
		system("CLS");
        return funcis;
    }

    printf(" ________________________________________\n");
	printf("|                                        \n");
 	printf("|  Digite o código do funcionário que deseja demitir: ");
 	scanf("%d", &cod);
	printf("|  Digite o CPF do funcionário que deseja demitir: ");
 	scanf("%d", &cpf);
	
	
	
    for (i = 0; i < *n; i++) {
        if (funcis[i].cod == cod || funcis[i].cpf == cpf) {
        	printf("|  Demitindo funcionário com codigo %d e CPF %d...\n", cod, cpf);
        	
			for (j = i; j < *n - 1; j++) {
                funcis[j] = funcis[j + 1];
            }
            (*n)--;
            
            funcis = (Funcionario*)realloc(funcis, (*n) * sizeof(Funcionario));
			printf("|                                        \n");
			printf("|  Dados retirados com sucesso!\n");
			printf("|________________________________________\n");
			
			printf("\n\t\tRetirado!\n");
			
            printf("\n\nFuncionário demitido com sucesso!\n\n");
            printf("\nPressione qualquer tecla para continuar");
			system("pause > nul");
			system("CLS");
            
            return funcis;
        }
    }
    printf("\n\nFuncionário com código %d não encontrado.\n", cod);
    
    printf("\nPressione qualquer tecla para continuar");
	system("pause > nul");
	system("CLS");
	
    return funcis;
}

void acess_funcis(Funcionario *funcis, int n) {
	system("cls");
	setlocale(LC_ALL, "Portuguese");
	struct cliente *head_cliente= NULL;
	int h = 0, m = 0, escolha;
	
	const char *opcoes_menu_principal[] = {
        "Alterar funcionário",
        "Excluir funcionário",
        "Voltar",
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);
    
    do {
    	escolha = mostrarMenu("ACESSAR FUNC.", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
        	case 0:
        		system("cls");
                printf("\n\nAtualizando Funcionário...\n\n");
                system("pause");
                atual_funcis(funcis, n);
                break;
            case 1:
            	system("cls");
                printf("\n\nExcluindo Funcionário...\n\n");
                system("pause");
                funcis = demit_funcis(funcis, &n);
                break; 
			case 2:
				system("cls");
                printf("\n  Voltando...\n\n");
                Sleep(2000);
                break;
            default:
                printf("Opção inválida!\n\n");
        }
    } while (escolha != 2);
}

void recuperarSenha() {
	setlocale(LC_ALL, "Portuguese");
    Funcionario usuario;
    char login[20];

    printf("\n =========== Recuperação de Senha ===========\n\n");
    printf("Informe o usuário: ");
    scanf("%s", login);

    if (carregarFuncionario(login, &usuario)) {
        printf("\n\tSenha do %s (%s): %s\n\n", usuario.cargo, usuario.nome, usuario.senha);
        system("pause");
        system("cls");
    } else {
        printf("\n\tUsuário não encontrado!\n\n");
        system("pause");
        system("cls");
    }
}

// Menu do Gerente
void menuGerente() {
	setlocale(LC_ALL, "Portuguese");
	SetConsoleTitle("BANZEIRO - GERENTE");
	Funcionario *funcis = NULL;
	struct cliente *head_cliente= NULL;
	int n = 0, m = 0, escolha;
	
	const char *opcoes_menu_principal[] = {
        "Cadastrar funcionário",
        "Acessar funcionário",
        "Leis",
        "Sair",
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);
    
    do {
    	escolha = mostrarMenu("MENU GERENTE", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
        	case 0:
        		system("cls");
                printf("\n  Cadastrando Funcionário...\n\n");
                Sleep(2000);
                funcis = cadas_funcis(funcis, &n);
                break;
            case 1:
            	system("cls");
                printf("\n  Acessando Funcionários...\n\n");
                Sleep(2000);
                acess_funcis(funcis, n);
                break; 
            case 2:
            	printf("\n  Leis\n");
            	break;
			case 3:
				system("cls");
                printf("\n  Saindo...\n\n");
                Sleep(2000);
                break;
            default:
                printf("\n\nOpção inválida!\n\n");
        }
    } while (escolha != 3);
}

void acessClien() {
	setlocale(LC_ALL, "Portuguese");
	SetConsoleTitle("BANZEIRO - FUNCIONÁRIO");
	int n = 0, m = 0, escolha;
	
	const char *opcoes_menu_principal[] = {
		"Alterar cliente",
		"Excluir cliente",
        "Voltar",
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);
    
    do {
        escolha = mostrarMenu("ACESSAR CLIENTE", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
            case 0: 
            	system("cls");
				break;
			case 1:
				system("cls");
				break;
			case 2:
				system("cls");
                printf("\n  Voltando...\n\n");
                Sleep(2000);
                break;				
        }
    } while (escolha != 2);
}

void areaClien() {
	setlocale(LC_ALL, "Portuguese");
	SetConsoleTitle("BANZEIRO - FUNCIONÁRIO");
	int n = 0, m = 0, escolha;
	
	const char *opcoes_menu_principal[] = {
		"Cadastro de cliente",
		"Acessar cliente",
        "Voltar",
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);
    
    do {
        escolha = mostrarMenu("ÁREA CLIENTE", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
            case 0: 
            	system("cls");
				break;
			case 1:
				system("cls");
				printf("\n  Acessando clientes...\n\n");
				Sleep(2000);
				acessClien();
				break;
			case 2:
				system("cls");
                printf("\n  Voltando...\n\n");
                Sleep(2000);
                break;				
        }
    } while (escolha != 2);
}

void menuFuncionario() {
	setlocale(LC_ALL, "Portuguese");
	SetConsoleTitle("BANZEIRO - FUNCIONÁRIO");
	int n = 0, m = 0, escolha;
	
	const char *opcoes_menu_principal[] = {
		"Área do cliente",
		"Rotas",
        "Leis",
        "Sair",
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);
    
    do {
        escolha = mostrarMenu("MENU FUNCIONARIO", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
            case 0: 
            	system("cls");
            	printf("\n  Entrando na área do cliente...\n\n");
				Sleep(2000);
        		areaClien();
				break;
			case 1:
				system("cls");
				printf("\n  Calculando rotas...\n\n");
				Sleep(2000);
				menuRotas();
				break;
			case 2:
				system("cls");
				printf("Leis\n"); 
				break;
			case 3:
				system("cls");
                printf("\n  Saindo...\n\n");
                Sleep(2000);
                break;
        }
    } while (escolha != 3);
}

void menuRotas(){
	const char *opcoes_menu_principal[] = {
        "Listar rotas disponíveis",
        "Destinos mais populares",
        "Destinos mais acessíveis",
        "Voltar"
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);

    int escolha;
    struct cliente *head_cliente = NULL; // Inicializa a lista de clientes

    do {
        escolha = mostrarMenu("MENU DE ROTAS", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
            case 0:
                listarRotas(&head_cliente); // Passa o endereço de head_cliente
                break;
            case 1:
                filtrarRotas(1, &head_cliente); // Passa o endereço de head_cliente
                break;
            case 2:
                filtrarRotas(2, &head_cliente); // Passa o endereço de head_cliente
                break;
            case 3:
                system("cls");
                printf("\n  Voltando...\n\n");
                Sleep(2000);
        }
    } while (escolha != 3); // 3 é o índice da opção "Sair"
}

void login() {
	setlocale(LC_ALL, "Portuguese");
    Funcionario usuario;
    char login[20], senha[20];
    int i = 0;

    printf("\n ============= Login do Usuário =============\n\n");
    printf("   Usuário: ");
    scanf("%s", login);
    printf("   Senha: ");

    // Mascarando a entrada da senha
    while (1) {
        char ch = getch();  // Captura o caractere sem exibi-lo
        if (ch == 13) {     // Enter
            senha[i] = '\0'; // Finaliza a string da senha
            break;
        } else if (ch == 8) { // Backspace
            if (i > 0) {
                i--;
                printf("\b \b"); // Apaga o ?ltimo caractere na tela
            }
        } else {
            senha[i++] = ch;  // Armazena o caractere na senha
            printf("*");       // Exibe um asterisco
        }
    }
    printf("\n");

    if (carregarFuncionario(login, &usuario)) {
    	setlocale(LC_ALL, "Portuguese");
        if (strcmp(usuario.senha, senha) == 0) {
            printf("\n\n\tBem-vindo(a), %s! (%s)\n", usuario.nome, usuario.cargo);
            Sleep(4200);
            
            animarBarco();  // Exibe a animação do barco

            if (strcmp(usuario.cargo, "Gerente") == 0) {
                system("cls");
				menuGerente();
            } else {
            	system("cls");
                menuFuncionario();
            }
        } else {
            printf("Senha incorreta!\n");
            Sleep(2200);
            system("cls");
        }
    } else {
        printf("Usuário não encontrado!\n");
    }
}
int mostrarMenu(const char *titulo, const char **opcoes, int numOpcoes) {
    int posicao = 0; // Inicializa a posição do cursor
    int tecla;

    do {
        system(CLEAR);
        printf("\n======= %s =======\n\n", titulo); // Exibe o título do menu

        // Exibe as opções do menu com a seta indicando a opção atual
        for (i = 0; i < numOpcoes; i++) {
            setColor(posicao == i ? 14 : 7); // Amarelo para a opção selecionada
            printf(" -> %s\n", opcoes[i]);
            setColor(7); // Reset para a cor padrão
        }

        tecla = _getch();

        if (tecla == 224) { // Teclas de seta
            tecla = _getch();
            switch (tecla) {
                case 72: // Seta para cima
                    if (posicao > 0) posicao--;
                    break;
                case 80: // Seta para baixo
                    if (posicao < numOpcoes - 1) posicao++;
                    break;
            }
        } else if (tecla == 13) { // Enter
            return posicao; // Retorna a opção selecionada
        }
    } while (tecla != 27); // ESC para sair do menu

    return -1; // Retorna -1 se o usuário pressionar ESC
}

int main() {
    setlocale(LC_ALL, "Portuguese");
    SetConsoleTitle("BANZEIRO");
    Funcionario gerente = {"Ana", "admin", "1234", "Gerente", 01, "1234"};
    Funcionario funcionario = {"João", "func", "abcd", "Funcionário", 02, "5456789"};
    salvarFuncionario("admin", &gerente);
    salvarFuncionario("func", &funcionario);
    salvarFuncionario("funcionarios.dat", &gerente);
    
    const char *opcoes_menu_principal[] = {
        "Login",
        "Recuperar Senha",
        "Sair",
    };
    int num_opcoes_menu_principal = sizeof(opcoes_menu_principal) / sizeof(opcoes_menu_principal[0]);

    int escolha;
    do {
        escolha = mostrarMenu("MENU", opcoes_menu_principal, num_opcoes_menu_principal);

        switch (escolha) {
            case 0: 
				system("cls");
				login(); 
				break;
            case 1: 
				system("cls");
				recuperarSenha(); 
				break;
			case 2: 
				system("cls");
				printf("\n ========== Encerrando, até amanhã! ==========\n\n");
            	Sleep(2000);
				break;
            default: 
				printf("Opção inválida!\n");
        }
    } while (escolha != 2);

    return 0;
}
